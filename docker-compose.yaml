name: myapp  # optional but recommended for clarity in logs and container names

# ====== Anchors (DRY) ======
x-env-common: &env_common
  DJANGO_SETTINGS_MODULE: ${DJANGO_SETTINGS_MODULE:-config.settings.prod}
  TZ: ${TZ:-Europe/Warsaw}
  PYTHONUNBUFFERED: "1"

x-logging: &logging_json
  driver: "json-file"
  options:
    max-size: "10m"
    max-file: "3"

x-health-gunicorn: &health_gunicorn
  # Application-level healthcheck (expects /api/health/ to return 2xx)
  test: ["CMD-SHELL", "wget -qO- http://127.0.0.1:8000/api/health/ || exit 1"]
  interval: 10s
  timeout: 5s
  retries: 8
  start_period: 25s

x-service-common: &service_common
  # Common runtime settings shared across services
  networks: [backend]
  restart: unless-stopped
  logging: *logging_json
  init: true                 # PID 1 reaper to avoid zombie processes
  ulimits:
    nofile:
      soft: 4096
      hard: 8192

x-django-common: &django_common
  # Shared settings for Django-based services
  build:
    context: .
    target: runtime
  environment:
    <<: *env_common
    # --- Database pieces (assembled in Django from secrets) ---
    DB_NAME: ${POSTGRES_DB:-app}
    DB_USER: ${POSTGRES_USER:-app}
    DB_HOST: db
    DB_PORT: "5432"
    DB_PASSWORD_FILE: /run/secrets/db_password
    # --- Redis (broker/result backend) — composed in code based on *_FILE ---
    REDIS_HOST: redis
    REDIS_PORT: "6379"
    REDIS_DB_BROKER: "0"
    REDIS_DB_BACKEND: "0"
    REDIS_PASSWORD_FILE: /run/secrets/redis_password
  env_file: [.env]
  depends_on:
    db:
      condition: service_healthy
    redis:
      condition: service_healthy
  read_only: true
  tmpfs: ["/tmp"]          # tmp directory for Gunicorn and temp files
  user: "${APP_UID:-1000}:${APP_GID:-1000}"  # avoid running as root
  security_opt:
    - no-new-privileges:true
  cap_drop: [ALL]

services:
    # ===== Database (Postgres) =====
  db:
    image: postgres:16-alpine
    command: ["postgres"]   # explicit for clarity (uses PGDATA below)
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-app}
      POSTGRES_USER: ${POSTGRES_USER:-app}
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
      TZ: ${TZ:-Europe/Warsaw}
      PGDATA: /var/lib/postgresql/data/pgdata
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 12
      start_period: 15s
    deploy:
      resources:
        limits:
          memory: 1g
          cpus: "1.0"
        reservations:
          memory: 512m
    <<: *service_common
    secrets: [db_password]
    profiles: ["prod", "dev"]

  # ===== Django + Gunicorn (production) =====
  web:
    <<: [*django_common, *service_common]
    command: >
      gunicorn config.wsgi:application
      --bind 0.0.0.0:8000
      --workers ${GUNICORN_WORKERS:-3}
      --threads ${GUNICORN_THREADS:-2}
      --timeout ${GUNICORN_TIMEOUT:-30}
      --access-logfile -
      --error-logfile -
    expose:
      - "8000"   # internal network only; Nginx terminates HTTP(S)
    volumes:
      - type: volume
        source: media_data
        target: /app/media
        volume: { nocopy: true }
      - type: volume
        source: static_data
        target: /app/staticfiles
        volume: { nocopy: true }
    # depends_on inherited from x-django-common
    healthcheck: *health_gunicorn
    deploy:
      resources:
        limits:
          memory: 1g
          cpus: "0.75"
        reservations:
          memory: 512m
    secrets: [db_password, redis_password]
    profiles: ["prod"]

  # ===== Django + Gunicorn (development) =====
  web-dev:
    <<: [*django_common, *service_common]
    command: >
      gunicorn config.wsgi:application
      --bind 0.0.0.0:8000
      --workers 2
      --threads 2
      --timeout 60
      --access-logfile -
      --error-logfile -
    expose:
      - "8000"
    volumes:
      - type: bind
        source: .
        target: /app
        consistency: cached
      - type: bind
        source: ./media
        target: /app/media
      - type: bind
        source: ./staticfiles
        target: /app/staticfiles
    environment:
      <<: *env_common
      DJANGO_SETTINGS_MODULE: ${DJANGO_SETTINGS_MODULE:-config.settings.dev}
      # In DEV, you can keep using DATABASE_URL instead of secrets
      DATABASE_URL: ${DATABASE_URL:-postgres://$${POSTGRES_USER:-app}:$${POSTGRES_PASSWORD:-app}@db:5432/$${POSTGRES_DB:-app}}
    # depends_on & env_file inherited from x-django-common
    healthcheck: *health_gunicorn
    read_only: false        # convenient for local dev (live reload, etc.)
    profiles: ["dev"]

  # ===== Nginx (reverse proxy / static) =====
  nginx:
    image: nginx:1.27-alpine
    command: ["nginx", "-g", "daemon off;"]
    ports:
      - "80:80"
      # - "443:443"   # enable if you terminate TLS here
    volumes:
      - ./deploy/nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - static_data:/app/staticfiles:ro
      - media_data:/app/media:ro
    depends_on:
      web:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://127.0.0.1/healthz || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 8
      start_period: 10s
    deploy:
      resources:
        limits:
          memory: 1g
          cpus: "0.5"
        reservations:
          memory: 128m
    user: "101:101"  # nginx user/group in the image; do not run as root
    read_only: true
    tmpfs: ["/var/cache/nginx","/var/run","/tmp"]
    cap_drop: [ALL]
    <<: *service_common
    profiles: ["prod", "dev"]


  # ===== Redis (production — no host port exposed) =====
  redis:
    image: redis:7-alpine
    # Secure Redis with password loaded from a Docker secret
    command: ["sh", "-c", "redis-server --appendonly yes --requirepass \"$(cat /run/secrets/redis_password)\""]
    volumes:
      - redis_data:/data
    environment:
      TZ: ${TZ:-Europe/Warsaw}
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 8
      start_period: 10s
    deploy:
      resources:
        limits:
          memory: 512m
          cpus: "0.5"
        reservations:
          memory: 256m
    <<: *service_common
    secrets: [redis_password]
    profiles: ["prod"]

  # ===== Redis (development — exposes 6379 on host) =====
  redis-dev:
    image: redis:7-alpine
    command: ["redis-server", "--appendonly", "yes"]
    ports:
      - "6379:6379"   # dev convenience; avoid exposing in production
    volumes:
      - redis_data:/data
    environment:
      TZ: ${TZ:-Europe/Warsaw}
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 8
      start_period: 10s
    deploy:
      resources:
        limits:
          memory: 512m
          cpus: "0.5"
        reservations:
          memory: 256m
    <<: *service_common
    profiles: ["dev"]

  # ===== Celery worker =====
  worker:
    <<: [*django_common, *service_common]
    command: celery -A config worker -l ${CELERY_LOGLEVEL:-info} --concurrency=${CELERY_CONCURRENCY:-4}
    # inherits env (DB_*, REDIS_*, *_FILE) and env_file from x-django-common
    volumes:
      - media_data:/app/media
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      web:
        condition: service_started
    healthcheck:
      test: ["CMD-SHELL", "python - <<'PY'\nimport sys; sys.exit(0)\nPY"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 20s
    deploy:
      resources:
        limits:
          memory: 1g
          cpus: "0.75"
        reservations:
          memory: 512m
    read_only: true
    tmpfs: ["/tmp"]
    secrets: [db_password, redis_password]
    profiles: ["prod", "dev"]

  # ===== Celery beat (scheduler) =====
  beat:
    <<: [*django_common, *service_common]
    command: celery -A config beat -l ${CELERY_LOGLEVEL:-info}
    # inherits env (DB_*, REDIS_*, *_FILE) and env_file from x-django-common
    volumes:
      - media_data:/app/media
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      web:
        condition: service_started
    healthcheck:
      test: ["CMD-SHELL", "python - <<'PY'\nimport sys; sys.exit(0)\nPY"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 20s
    deploy:
      resources:
        limits:
          memory: 1g
          cpus: "0.5"
        reservations:
          memory: 256m
    read_only: true
    tmpfs: ["/tmp"]
    secrets: [db_password, redis_password]
    profiles: ["prod", "dev"]

  # ===== One-off jobs =====
  migrate:
    <<: [*django_common, *service_common]
    command: python manage.py migrate --noinput
    depends_on:
      db:
        condition: service_healthy
    restart: "no"
    secrets: [db_password]
    profiles: [ "prod", "dev" ]

  collectstatic:
    <<: [*django_common, *service_common]
    command: python manage.py collectstatic --noinput
    volumes:
      - static_data:/app/staticfiles
    depends_on:
      web:
        condition: service_started
    restart: "no"
    secrets: [db_password]
    profiles: ["prod", "dev"]

# ===== Volumes =====
volumes:
  redis_data:
  postgres_data:
  media_data:
  static_data:

# ===== Networks =====
networks:
  backend:
    driver: bridge

# ===== Secrets =====
# In Compose (non-Swarm) these files must exist on the host; in Swarm use `external: true` and create them via `docker secret create`.
secrets:
  db_password:
    file: ./deploy/secrets/db_password.txt
  redis_password:
    file: ./deploy/secrets/redis_password.txt

# ===== Usage =====
# DEV (Compose):
#   docker compose --profile dev up --build --compatibility
#
# PROD (Compose — maps deploy.resources via compatibility mode):
#   docker compose --profile prod up -d --build --compatibility
#
# PROD (Swarm — full deploy.resources support):
#   docker swarm init
#   docker stack deploy -c docker-compose.yaml myapp
#   # update:
#   docker stack deploy -c docker-compose.yaml myapp
#   # inspect:
#   docker stack ps myapp
#   docker service ls
#
# One-off jobs (Compose):
#   docker compose run --rm migrate
#   docker compose run --rm collectstatic
